package com.ohgiraffers.section01.init;

public class Application {

    public static void main(String[] args) {
        
        /*title. 객체 배열에 대해서 이해할 수 있다*/

        /*comment.
        *   객체 배열이란, 레퍼런스 변수에 대한 배열이다.
        *   생성한 인스턴스도 배열을 이용해서 관리를 하게 된다면,
        *   동일한 타입의 여러 개 인스턴스를 각각 취급하지 않고
        *   연속처리를 할 수 있게 되어서 유용하다.
        *   또한 메소드의 반환값(return)은 1개의 값만 반환할 수 있기 때문에
        *   동일한 타입의 여러 인스턴스를 반환해야 하는 경우
        *   배열로 묶어서 반환할 수 있게 된다
        * */

        //객체배열은 배열과 다르게 값 대신 인스턴스를 넣습니다.

        Car car1 = new Car("페라리",300);
        Car car2 = new Car("G바겐",250);
        Car car3 = new Car("롤스로이스",250);
        Car car4 = new Car("부가티",400);
        Car car5 = new Car("케스퍼",500);

        car1.carMaxSpeedInfo();
        car2.carMaxSpeedInfo();
        car3.carMaxSpeedInfo();
        car4.carMaxSpeedInfo();
        car5.carMaxSpeedInfo();

        System.out.println("=============================================");

        Car[] carArr = new Car[5];
        carArr[0]=new Car("페라리",300);
        carArr[1]=new Car("G바겐",250);
        carArr[2]=new Car("롤스로이스",250);
        carArr[3]=new Car("부가티",400);
        carArr[4]=new Car("케스퍼",500);

        //배열의 장점 : 규칙이 있기 때문에 반복문을 사용할 수 있다.
        for(int i = 0 ; i<carArr.length; i++){
            carArr[i].carMaxSpeedInfo();
        }

        System.out.println("=============================================");

        //향상된 for 문도 사용할 수 있다.
        // : 이 붙는다는 것은 Car[] 를 순회하면서 하나씩 Car c에 넣어주겠다는 것이에요
        for(Car c : carArr){
            c.carMaxSpeedInfo();
        }
    }
}

// 기본자료형 배열 인덱스 공간에다가 값을 넣었다면
// 객체배열은 인스턴스를 집어넣은 것에요 영번째 인덱스 첫번째 회원 첫번째 인덱스 회원 인스턴스주소를 넣은 것이에요
// 상속 : 부모님의 돈은 저희의 돈 제돈은 저의 돈
// 자바에서 상속은 클래스를 좀더 다채롭게 만든다는 것입니다.
// 자식은 부모클래스의 멤버(필드, 메소드)를 마치 내것처럼 쓴다는 것입니다.
// extends 키워드가 확장이라는 뜻인데 부모가 가진 돈은 내돈 내돈도 내돈 그럼 자식이 돈이 더 많겠죠
// 자식은 부모의 것을 확장시켰다 라고 보면 되요 .
// 부모 만약에 돈을 100만원 주었다라고 하면은 자식은 100만원 + 20만원(내용돈) 자기자신만의 기능을 더 가지고 있는 조금 더 확장된 기능이라고 보면 됩니자.
// 상속은 부모의 것을 다채롭게 꾸밀 수 있다. 장점 기존 클래스의 재사용 가능 뭐가 좋을까요? 반복된 코드를 한번더 작성하지 않아도 된다는 것입니다.
// 코드를 2줄 작성 부모의 것을 물려받으면 하나의 코드로 부모와 자식 2개를 동시에 진행할 수 있다는 것입니다.
// IS-A 관계라고 말을 하는데요 예문을 들어볼께요. 소방차는 차일까 경찰차는 차일까요 차는 경찰차일까요 아니죠. 차라는 부모에서 목적에 따라 경찰차 소방차가 될 수 있는
// 것을 말해요
// 토끼는 동물일까요 동물은 토끼일까요? 확실하시 않죠 이런 식으로 이해해보아요.
// super 키워드가 나와요. this 와 비교하면 좋습니다. this 는 자기자신의 주소 this.age 멤버클래스의 age 를 나타내는데 super 는 말 그대로
// 상속받으면 그 부모를 지칭해요 조평훈이란 클래스가 있어요 . 조평훈은 사람이란 클래스를 상속받고요. 조평훈은 필드로 private int age 를 가지고 있어요
// this.age 라고 하면 어떻게 될까요. 20이라는 값을 가지죠. 사람이라는 클래스를 상속을 받아요. 평훈 클래스에서 super 라고 하면 부모의 주소를 가지고 있어요
// this 는 자기자신 super 는 내가 상속받은 부모클래스라고 보면 됩니다.
// 추상화 캡슐화 상속 다형성 객체지향언어의 3대특징이라고도 불려요
// 객체 지향은 따라가겠다는 거지 반드시 쓰라는 것은 아니나 추천하는 것
// 부모의 것을 받아서 조금 더 확장시킨다라는 개념이 맞아요

